.TH "inc/libft.h" 3 "Mon Feb 17 2025 19:18:19" "Libft" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inc/libft.h
.SH SYNOPSIS
.br
.PP
\fR#include <stddef\&.h>\fP
.br
\fR#include <unistd\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBs_list\fP"
.br
.RI "Structure for linked list\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBs_list\fP \fBt_list\fP"
.br
.RI "Structure for linked list\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBft_atoi\fP (const char *nptr)"
.br
.RI "Convert string to int, and handle number\&. "
.ti -1c
.RI "int \fBft_atoi_base\fP (char *str, char *base)"
.br
.RI "Atoi with a particular base\&. "
.ti -1c
.RI "void \fBft_bzero\fP (void *s, size_t n)"
.br
.RI "Set at 0, the n first bytes at the pointer adress\&. "
.ti -1c
.RI "void * \fBft_calloc\fP (size_t element_count, size_t element_size)"
.br
.RI "Allocates a new memory zone, and set all bits to zero\&. "
.ti -1c
.RI "int \fBft_check_base_atoi\fP (char *base)"
.br
.RI "Check if base is valid for atoi_base\&. "
.ti -1c
.RI "int \fBft_check_base_putnbr\fP (char *base)"
.br
.RI "Check if base is valid for putnbr_base\&. "
.ti -1c
.RI "int \fBft_isalnum\fP (int character)"
.br
.RI "Check if arg is a char or a digit\&. "
.ti -1c
.RI "int \fBft_isalpha\fP (int character)"
.br
.RI "Check if arg is a char\&. "
.ti -1c
.RI "int \fBft_isascii\fP (int character)"
.br
.RI "Check if arg is in ascii table\&. "
.ti -1c
.RI "int \fBft_isdigit\fP (int character)"
.br
.RI "Check if arg is a char\&. "
.ti -1c
.RI "int \fBft_isprint\fP (int character)"
.br
.RI "Check if arg is in ascii table\&. "
.ti -1c
.RI "int \fBft_isspace\fP (int character)"
.br
.RI "Check if arg is a whitespace\&. "
.ti -1c
.RI "int \fBft_iswhitespace\fP (int character)"
.br
.RI "Alternative name for ft_isspace\&. "
.ti -1c
.RI "char * \fBft_itoa\fP (int n)"
.br
.RI "Return a string representing the integer 'n' received as argument\&. "
.ti -1c
.RI "void \fBft_lstadd_back\fP (\fBt_list\fP **lst, \fBt_list\fP *new)"
.br
.RI "Adds the element ’new’ at the end of the list\&. "
.ti -1c
.RI "void \fBft_lstadd_front\fP (\fBt_list\fP **lst, \fBt_list\fP *new)"
.br
.RI "Adds the element ’new’ at the start of the list\&. "
.ti -1c
.RI "void \fBft_lstclear\fP (\fBt_list\fP **lst, void(*del)(void *))"
.br
.RI "Deletes and free the memory of the element passed as a parameter, and all the elements that follow, using 'del' and free(3) Finally, the initial pointer must be set to NULL\&. "
.ti -1c
.RI "void \fBft_lstdelone\fP (\fBt_list\fP *lst, void(*del)(void *))"
.br
.RI "Free the memory of the element passed as a parameter using the function 'del' and free(3)\&. The memory of next must not be freed\&. "
.ti -1c
.RI "void \fBft_lstiter\fP (\fBt_list\fP *lst, void(*f)(void *))"
.br
.RI "Iterate on the linked list 'lst' and apply the function 'f' on the content of each element\&. "
.ti -1c
.RI "\fBt_list\fP * \fBft_lstlast\fP (\fBt_list\fP *lst)"
.br
.RI "Returns the last element of the list\&. "
.ti -1c
.RI "\fBt_list\fP * \fBft_lstmap\fP (\fBt_list\fP *lst, void *(*f)(void *), void(*del)(void *))"
.br
.RI "Iterated on the linked list 'list' and apply the function 'f' on the content of each element\&. Create a new list resulting from the successive applications of 'f'\&. The function 'del' is there to destroy the content of an element if necessary\&. "
.ti -1c
.RI "\fBt_list\fP * \fBft_lstnew\fP (void *content)"
.br
.RI "Allocate (with malloc(3)) and return a new element\&. The variable member 'content' is initialized with the value of the parameter 'content'\&. The variable 'next' is initialized to NULL\&. "
.ti -1c
.RI "int \fBft_lstsize\fP (\fBt_list\fP *lst)"
.br
.RI "Count the number of elements in a list\&. "
.ti -1c
.RI "void * \fBft_memchr\fP (const void *memory_block, int searched_char, size_t size)"
.br
.RI "Research the first occurence of a value typed int, but interpreted as a char in a memory block\&. "
.ti -1c
.RI "int \fBft_memcmp\fP (const void *src, const void *set, size_t size)"
.br
.RI "Compares the first size bytes of the memory areas src and set\&. "
.ti -1c
.RI "void * \fBft_memcpy\fP (void *destination, const void *source, size_t size)"
.br
.RI "Set a memory zone with a value, count times\&. "
.ti -1c
.RI "void * \fBft_memmove\fP (void *destination, const void *source, size_t size)"
.br
.RI "Moves the memory blocks avoiding overlapping, until size blocks\&. "
.ti -1c
.RI "void * \fBft_memset\fP (void *pointer, int value, size_t count)"
.br
.RI "Set a memory zone with a value, count times\&. "
.ti -1c
.RI "ssize_t \fBft_putchar_fd\fP (char c, int fd)"
.br
.RI "Print the character 'c' on the file descriptor\&. "
.ti -1c
.RI "ssize_t \fBft_putendl_fd\fP (char *s, int fd)"
.br
.RI "Print the string 's' on the file descriptor, followed by a newline\&. "
.ti -1c
.RI "ssize_t \fBft_putnbr_base\fP (int nbr, char *base)"
.br
.RI "Putnbr with a particular base\&. "
.ti -1c
.RI "ssize_t \fBft_putnbr_bin\fP (int nbr)"
.br
.RI "Putnbr for binary\&. "
.ti -1c
.RI "ssize_t \fBft_putnbr_fd\fP (int n, int fd)"
.br
.RI "Print the integer ’n’ on the given file descriptor\&. "
.ti -1c
.RI "ssize_t \fBft_putnbr_hex\fP (int nbr, char height)"
.br
.RI "Putnbr for hex or HEX\&. "
.ti -1c
.RI "ssize_t \fBft_putnbr_oct\fP (int nbr)"
.br
.RI "Putnbr for octal\&. "
.ti -1c
.RI "void \fBft_putnbr_poneyvif\fP (int nbr)"
.br
.ti -1c
.RI "ssize_t \fBft_putnendl_fd\fP (char *s, size_t len, int fd)"
.br
.RI "Print the string 's' on the file descriptor, followed by a newline until a given size or the length of s if len is greater\&. "
.ti -1c
.RI "ssize_t \fBft_putnstr_fd\fP (char *s, size_t len, int fd)"
.br
.RI "Print the string 's' on the file descriptor until a given size or the length of s if len is greater\&. "
.ti -1c
.RI "ssize_t \fBft_putpointer_fd\fP (void *ptr)"
.br
.RI "Print pointer adress\&. "
.ti -1c
.RI "ssize_t \fBft_putstr_fd\fP (char *s, int fd)"
.br
.RI "Print the string 's' on the file descriptor\&. "
.ti -1c
.RI "void \fBft_rev_int\fP (int *tab, size_t size)"
.br
.RI "Reverse an array of ints\&. "
.ti -1c
.RI "char ** \fBft_split\fP (char const *s, char c)"
.br
.RI "Allocates with a malloc and returns an array of strings obtained by separating ’s’ using the character ’c’, used as a delimiter\&. The array must be terminated by NULL\&. "
.ti -1c
.RI "char * \fBft_strchr\fP (const char *string, int searched_char)"
.br
.RI "Find first occurrence of searched_char\&. "
.ti -1c
.RI "char * \fBft_strdup\fP (const char *source)"
.br
.RI "Create a copy of source into a new pointer NEEDS to be freed\&. "
.ti -1c
.RI "void \fBft_striteri\fP (char *s, void(*f)(unsigned int, char *))"
.br
.RI "Iterate the function f on string s\&. "
.ti -1c
.RI "char * \fBft_strjoin\fP (char const *s1, char const *s2)"
.br
.RI "Allocates a new string, and returns the result of a concatenation of s1 and s2\&. "
.ti -1c
.RI "size_t \fBft_strlcat\fP (char *dst, char *src, size_t size)"
.br
.RI "Concatenate src into dst, up to size bytes\&. "
.ti -1c
.RI "size_t \fBft_strlcpy\fP (char *dst, char *src, unsigned int size)"
.br
.ti -1c
.RI "size_t \fBft_strlen\fP (const char *the_string)"
.br
.RI "Len of string without '\\0'\&. "
.ti -1c
.RI "char * \fBft_strmapi\fP (char const *s, char(*f)(unsigned int, char))"
.br
.RI "Apply the function ’f’ to each character of the string ’s’, passing its index as first argument and the character itself as second argument\&. "
.ti -1c
.RI "int \fBft_strncmp\fP (const char *first, const char *second, size_t length)"
.br
.RI "Find differences between first and second\&. "
.ti -1c
.RI "char * \fBft_strndup\fP (const char *source, size_t len)"
.br
.RI "Create a copy of source into a new pointer of size len NEEDS to be freed\&. "
.ti -1c
.RI "char * \fBft_strnstr\fP (const char *big, const char *little, size_t len)"
.br
.RI "Search a substring in a bigger string, up to len position in string\&. "
.ti -1c
.RI "char * \fBft_strrchr\fP (const char *string, int searched_char)"
.br
.RI "Find last occurrence of searched_char\&. "
.ti -1c
.RI "char * \fBft_strtrim\fP (char const *s, char const *set)"
.br
.RI "Deletes all characters that exist in s and set, if they are at the beginning of the string or at the end\&. "
.ti -1c
.RI "char * \fBft_substr\fP (char const *src, unsigned int start, size_t len)"
.br
.RI "Create a copy of source into a new pointer, at start, of size len NEEDS to be freed\&. "
.ti -1c
.RI "void \fBft_swap_char\fP (char *a, char *b)"
.br
.RI "Swap 2 char values\&. "
.ti -1c
.RI "void \fBft_swap_char_no_temp\fP (char *a, char *b)"
.br
.RI "Works similarly as ft_swap_char but doens't use temporary variable SHOULD NOT BE USED IF a and b points at the same adress\&. "
.ti -1c
.RI "void \fBft_swap_int\fP (int *a, int *b)"
.br
.RI "Swap 2 int values\&. "
.ti -1c
.RI "void \fBft_swap_int_no_temp\fP (int *a, int *b)"
.br
.RI "Works similarly as ft_swap_int but doens't use temporary variable SHOULD NOT BE USED IF a and b points at the same adress\&. "
.ti -1c
.RI "void \fBft_swap_mem\fP (void **a, void **b)"
.br
.RI "Swap 2 memory adresses\&. "
.ti -1c
.RI "void \fBft_swap_mem_no_temp\fP (void **a, void **b)"
.br
.ti -1c
.RI "void \fBft_swap_nodes\fP (\fBt_list\fP **start, \fBt_list\fP *lst1, \fBt_list\fP *lst2)"
.br
.RI "Swap two nodes in a linked list (swap nodes, not content) "
.ti -1c
.RI "void \fBft_swap_str\fP (char **a, char **b)"
.br
.RI "Swap 2 string addresses\&. "
.ti -1c
.RI "void \fBft_swap_str_no_temp\fP (char **a, char **b)"
.br
.ti -1c
.RI "int \fBft_tolower\fP (int character)"
.br
.RI "Transform majuscules into minuscules\&. "
.ti -1c
.RI "int \fBft_toupper\fP (int character)"
.br
.RI "Transform minuscules into majuscules\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBs_list\fP \fBt_list\fP"

.PP
Structure for linked list\&. 
.SH "Function Documentation"
.PP 
.SS "int ft_atoi (const char * nptr)"

.PP
Convert string to int, and handle number\&. 
.PP
\fBParameters\fP
.RS 4
\fInptr\fP string to convert 
.RE
.PP
\fBReturns\fP
.RS 4
int number 
.RE
.PP

.PP
Definition at line \fB19\fP of file \fBft_atoi\&.c\fP\&.
.SS "int ft_atoi_base (char * str, char * base)"

.PP
Atoi with a particular base\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP String to convert 
.br
\fIbase\fP Base to use for conversion 
.RE
.PP
\fBReturns\fP
.RS 4
int converted number 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBft_atoi_base\&.c\fP\&.
.SS "void ft_bzero (void * s, size_t n)"

.PP
Set at 0, the n first bytes at the pointer adress\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP pointer to the memory to set 
.br
\fIn\fP number of bytes to set at 0 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_bzero\&.c\fP\&.
.SS "void * ft_calloc (size_t element_count, size_t element_size)"

.PP
Allocates a new memory zone, and set all bits to zero\&. 
.PP
\fBParameters\fP
.RS 4
\fIelement_count\fP number of elements 
.br
\fIelement_size\fP size of each element 
.RE
.PP
\fBReturns\fP
.RS 4
void* pointer to the new memory zone 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBft_calloc\&.c\fP\&.
.SS "int ft_check_base_atoi (char * base)"

.PP
Check if base is valid for atoi_base\&. 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP base to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if valid, 0 if not 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_convert_base\&.c\fP\&.
.SS "int ft_check_base_putnbr (char * base)"

.PP
Check if base is valid for putnbr_base\&. 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP base to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if valid, 0 if not 
.RE
.PP

.PP
Definition at line \fB51\fP of file \fBft_convert_base\&.c\fP\&.
.SS "int ft_isalnum (int character)"

.PP
Check if arg is a char or a digit\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 not char, anything else is char or digit 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_isalnum\&.c\fP\&.
.SS "int ft_isalpha (int character)"

.PP
Check if arg is a char\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 not char, anything else is char 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_isalpha\&.c\fP\&.
.SS "int ft_isascii (int character)"

.PP
Check if arg is in ascii table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 not in ascii table, anything else if in ascii table 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_isascii\&.c\fP\&.
.SS "int ft_isdigit (int character)"

.PP
Check if arg is a char\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 not char, anything else is char 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_isdigit\&.c\fP\&.
.SS "int ft_isprint (int character)"

.PP
Check if arg is in ascii table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 not in ascii table, anything else if in ascii table 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_isprint\&.c\fP\&.
.SS "int ft_isspace (int character)"

.PP
Check if arg is a whitespace\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 0 not space, anything else is a whitespace 
.RE
.PP

.PP
Definition at line \fB19\fP of file \fBft_isspace\&.c\fP\&.
.SS "int ft_iswhitespace (int character)"

.PP
Alternative name for ft_isspace\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.PP
Definition at line \fB32\fP of file \fBft_isspace\&.c\fP\&.
.SS "char * ft_itoa (int n)"

.PP
Return a string representing the integer 'n' received as argument\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP integer to convert 
.RE
.PP
\fBReturns\fP
.RS 4
char* string representing the integer 'n' 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_itoa\&.c\fP\&.
.SS "void ft_lstadd_back (\fBt_list\fP ** lst, \fBt_list\fP * new)"

.PP
Adds the element ’new’ at the end of the list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP head of the linked list 
.br
\fInew\fP new node to add 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_lstadd_back_bonus\&.c\fP\&.
.SS "void ft_lstadd_front (\fBt_list\fP ** lst, \fBt_list\fP * new)"

.PP
Adds the element ’new’ at the start of the list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP head of the linked list 
.br
\fInew\fP new node to add 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_lstadd_front_bonus\&.c\fP\&.
.SS "void ft_lstclear (\fBt_list\fP ** lst, void(* del )(void *))"

.PP
Deletes and free the memory of the element passed as a parameter, and all the elements that follow, using 'del' and free(3) Finally, the initial pointer must be set to NULL\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP head of the linked list 
.br
\fIdel\fP function to apply to delete all the content of the element 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_lstclear_bonus\&.c\fP\&.
.SS "void ft_lstdelone (\fBt_list\fP * lst, void(* del )(void *))"

.PP
Free the memory of the element passed as a parameter using the function 'del' and free(3)\&. The memory of next must not be freed\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP head of the linked list 
.br
\fIdel\fP function to apply to delete all the content of the element 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_lstdelone_bonus\&.c\fP\&.
.SS "void ft_lstiter (\fBt_list\fP * lst, void(* f )(void *))"

.PP
Iterate on the linked list 'lst' and apply the function 'f' on the content of each element\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP head of the linked list 
.br
\fIf\fP function to apply to the content of each element 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBft_lstiter_bonus\&.c\fP\&.
.SS "\fBt_list\fP * ft_lstlast (\fBt_list\fP * lst)"

.PP
Returns the last element of the list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP head of the linked list 
.RE
.PP
\fBReturns\fP
.RS 4
t_list* last element of the list 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_lstlast_bonus\&.c\fP\&.
.SS "\fBt_list\fP * ft_lstmap (\fBt_list\fP * lst, void *(* f )(void *), void(* del )(void *))"

.PP
Iterated on the linked list 'list' and apply the function 'f' on the content of each element\&. Create a new list resulting from the successive applications of 'f'\&. The function 'del' is there to destroy the content of an element if necessary\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP head of the linked list 
.br
\fIf\fP function to apply to the content of each element 
.br
\fIdel\fP function to apply to delete all the content of the element 
.RE
.PP
\fBReturns\fP
.RS 4
t_list* new list modified by f 
.RE
.PP

.PP
Definition at line \fB32\fP of file \fBft_lstmap_bonus\&.c\fP\&.
.SS "\fBt_list\fP * ft_lstnew (void * content)"

.PP
Allocate (with malloc(3)) and return a new element\&. The variable member 'content' is initialized with the value of the parameter 'content'\&. The variable 'next' is initialized to NULL\&. 
.PP
\fBParameters\fP
.RS 4
\fIcontent\fP content to add to the new element 
.RE
.PP
\fBReturns\fP
.RS 4
t_list* new element 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBft_lstnew_bonus\&.c\fP\&.
.SS "int ft_lstsize (\fBt_list\fP * lst)"

.PP
Count the number of elements in a list\&. 
.PP
\fBParameters\fP
.RS 4
\fIlst\fP list to count 
.RE
.PP
\fBReturns\fP
.RS 4
int number of elements in the list 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_lstsize_bonus\&.c\fP\&.
.SS "void * ft_memchr (const void * memory_block, int searched_char, size_t size)"

.PP
Research the first occurence of a value typed int, but interpreted as a char in a memory block\&. 
.PP
\fBParameters\fP
.RS 4
\fImemory_block\fP memory block to search in 
.br
\fIsearched_char\fP value to search 
.br
\fIsize\fP size of the memory block 
.RE
.PP
\fBReturns\fP
.RS 4
void* pointer to the first occurence of the value or NULL if not found 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBft_memchr\&.c\fP\&.
.SS "int ft_memcmp (const void * src, const void * set, size_t size)"

.PP
Compares the first size bytes of the memory areas src and set\&. 
.PP
\fBParameters\fP
.RS 4
\fIsrc\fP source memory block 
.br
\fIset\fP set memory block 
.br
\fIsize\fP size of the memory block 
.RE
.PP
\fBReturns\fP
.RS 4
int difference between the first different byte 
.RE
.PP

.PP
Definition at line \fB23\fP of file \fBft_memcmp\&.c\fP\&.
.SS "void * ft_memcpy (void * destination, const void * source, size_t size)"

.PP
Set a memory zone with a value, count times\&. 
.PP
\fBParameters\fP
.RS 4
\fIdestination\fP memory zone to paste 
.br
\fIsource\fP memory zone to copy 
.br
\fIsize\fP number of times to set the value 
.RE
.PP
\fBReturns\fP
.RS 4
void* pointer to the memory zone 
.RE
.PP

.PP
Definition at line \fB23\fP of file \fBft_memcpy\&.c\fP\&.
.SS "void * ft_memmove (void * destination, const void * source, size_t size)"

.PP
Moves the memory blocks avoiding overlapping, until size blocks\&. 
.PP
\fBParameters\fP
.RS 4
\fIdestination\fP destination memory block 
.br
\fIsource\fP source memory block 
.br
\fIsize\fP size of the memory block 
.RE
.PP
\fBReturns\fP
.RS 4
void* pointer to the destination memory block 
.RE
.PP

.PP
Definition at line \fB23\fP of file \fBft_memmove\&.c\fP\&.
.SS "void * ft_memset (void * pointer, int value, size_t count)"

.PP
Set a memory zone with a value, count times\&. 
.PP
\fBParameters\fP
.RS 4
\fIpointer\fP memory zone to set 
.br
\fIvalue\fP value to set 
.br
\fIcount\fP number of times to set the value 
.RE
.PP
\fBReturns\fP
.RS 4
void* pointer to the memory zone 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_memset\&.c\fP\&.
.SS "ssize_t ft_putchar_fd (char c, int fd)"

.PP
Print the character 'c' on the file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP character to print 
.br
\fIfd\fP file descriptor 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t number of char printed 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBft_putchar_fd\&.c\fP\&.
.SS "ssize_t ft_putendl_fd (char * s, int fd)"

.PP
Print the string 's' on the file descriptor, followed by a newline\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to print 
.br
\fIfd\fP file descriptor 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t number of char printed 
.RE
.PP

.PP
Definition at line \fB23\fP of file \fBft_putendl_fd\&.c\fP\&.
.SS "ssize_t ft_putnbr_base (int nbr, char * base)"

.PP
Putnbr with a particular base\&. 
.PP
\fBParameters\fP
.RS 4
\fInbr\fP number to print 
.br
\fIbase\fP base to use 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t number of char printed 
.RE
.PP

.PP
Definition at line \fB23\fP of file \fBft_putnbr_base\&.c\fP\&.
.SS "ssize_t ft_putnbr_bin (int nbr)"

.PP
Putnbr for binary\&. 
.PP
\fBParameters\fP
.RS 4
\fInbr\fP number to print 
.RE
.PP

.PP
Definition at line \fB54\fP of file \fBft_putnbr_base\&.c\fP\&.
.SS "ssize_t ft_putnbr_fd (int n, int fd)"

.PP
Print the integer ’n’ on the given file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP integer to print 
.br
\fIfd\fP file descriptor 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t number of char printed 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBft_putnbr_fd\&.c\fP\&.
.SS "ssize_t ft_putnbr_hex (int nbr, char height)"

.PP
Putnbr for hex or HEX\&. 
.PP
\fBParameters\fP
.RS 4
\fInbr\fP number to print 
.br
\fIheight\fP 1 for hex, 0 for HEX 
.RE
.PP

.PP
Definition at line \fB75\fP of file \fBft_putnbr_base\&.c\fP\&.
.SS "ssize_t ft_putnbr_oct (int nbr)"

.PP
Putnbr for octal\&. 
.PP
\fBParameters\fP
.RS 4
\fInbr\fP number to print 
.RE
.PP

.PP
Definition at line \fB64\fP of file \fBft_putnbr_base\&.c\fP\&.
.SS "void ft_putnbr_poneyvif (int nbr)"

.SS "ssize_t ft_putnendl_fd (char * s, size_t len, int fd)"

.PP
Print the string 's' on the file descriptor, followed by a newline until a given size or the length of s if len is greater\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to print 
.br
\fIlen\fP maximum char to be printed 
.br
\fIfd\fP file descriptor 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t nombre de caractere qui ont été écrits 
.RE
.PP

.PP
Definition at line \fB37\fP of file \fBft_putendl_fd\&.c\fP\&.
.SS "ssize_t ft_putnstr_fd (char * s, size_t len, int fd)"

.PP
Print the string 's' on the file descriptor until a given size or the length of s if len is greater\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to print 
.br
\fIlen\fP maximum char to be printed 
.br
\fIfd\fP nombre de caractere qui ont été écrits 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t nombre de caractere qui ont été écrits 
.RE
.PP

.PP
Definition at line \fB37\fP of file \fBft_putstr_fd\&.c\fP\&.
.SS "ssize_t ft_putpointer_fd (void * ptr)"

.PP
Print pointer adress\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP pointer to print 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t number of char printed 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_putpointer_fd\&.c\fP\&.
.SS "ssize_t ft_putstr_fd (char * s, int fd)"

.PP
Print the string 's' on the file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to print 
.br
\fIfd\fP file descriptor 
.RE
.PP
\fBReturns\fP
.RS 4
ssize_t nombre de caractere qui ont été écrits 
.RE
.PP

.PP
Definition at line \fB23\fP of file \fBft_putstr_fd\&.c\fP\&.
.SS "void ft_rev_int (int * tab, size_t size)"

.PP
Reverse an array of ints\&. 
.PP
\fBParameters\fP
.RS 4
\fItab\fP adress of the first element of the array 
.br
\fIsize\fP number of elements in the array 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_rev_int\&.c\fP\&.
.SS "char ** ft_split (char const * s, char c)"

.PP
Allocates with a malloc and returns an array of strings obtained by separating ’s’ using the character ’c’, used as a delimiter\&. The array must be terminated by NULL\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to print 
.br
\fIc\fP char used as a delimiter 
.RE
.PP
\fBReturns\fP
.RS 4
char** array of strings 
.RE
.PP

.PP
Definition at line \fB29\fP of file \fBft_split\&.c\fP\&.
.SS "char * ft_strchr (const char * string, int searched_char)"

.PP
Find first occurrence of searched_char\&. 
.PP
\fBParameters\fP
.RS 4
\fIstring\fP string to search in 
.br
\fIsearched_char\fP char to search 
.RE
.PP
\fBReturns\fP
.RS 4
char* index of Char found 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBft_strchr\&.c\fP\&.
.SS "char * ft_strdup (const char * source)"

.PP
Create a copy of source into a new pointer NEEDS to be freed\&. 
.PP
\fBParameters\fP
.RS 4
\fIsource\fP string to copy 
.RE
.PP
\fBReturns\fP
.RS 4
char* pointer to the new string 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_strdup\&.c\fP\&.
.SS "void ft_striteri (char * s, void(* f )(unsigned int, char *))"

.PP
Iterate the function f on string s\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to iterate 
.br
\fIf\fP function to apply 
.RE
.PP

.PP
Definition at line \fB19\fP of file \fBft_striteri\&.c\fP\&.
.SS "char * ft_strjoin (char const * s1, char const * s2)"

.PP
Allocates a new string, and returns the result of a concatenation of s1 and s2\&. 
.PP
\fBParameters\fP
.RS 4
\fIs1\fP string 1 
.br
\fIs2\fP string 2 
.RE
.PP
\fBReturns\fP
.RS 4
char* new string 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_strjoin\&.c\fP\&.
.SS "size_t ft_strlcat (char * dst, char * src, size_t size)"

.PP
Concatenate src into dst, up to size bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIdst\fP destination string 
.br
\fIsrc\fP source string 
.br
\fIsize\fP size of the destination string 
.RE
.PP
\fBReturns\fP
.RS 4
unsigned int size of the new string 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_strlcat\&.c\fP\&.
.SS "size_t ft_strlcpy (char * dst, char * src, unsigned int size)"

.SS "size_t ft_strlen (const char * the_string)"

.PP
Len of string without '\\0'\&. 
.PP
\fBParameters\fP
.RS 4
\fIthe_string\fP string to check 
.RE
.PP
\fBReturns\fP
.RS 4
size_t len of the string 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBft_strlen\&.c\fP\&.
.SS "char * ft_strmapi (char const * s, char(* f )(unsigned int, char))"

.PP
Apply the function ’f’ to each character of the string ’s’, passing its index as first argument and the character itself as second argument\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to iterate 
.br
\fIf\fP function to apply 
.RE
.PP
\fBReturns\fP
.RS 4
char* new string 
.RE
.PP

.PP
Definition at line \fB26\fP of file \fBft_strmapi\&.c\fP\&.
.SS "int ft_strncmp (const char * first, const char * second, size_t length)"

.PP
Find differences between first and second\&. 
.PP
\fBParameters\fP
.RS 4
\fIfirst\fP first string to compare 
.br
\fIsecond\fP second string to compare 
.br
\fIlength\fP number of characters to compare 
.RE
.PP
\fBReturns\fP
.RS 4
int value of first - second 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBft_strncmp\&.c\fP\&.
.SS "char * ft_strndup (const char * source, size_t len)"

.PP
Create a copy of source into a new pointer of size len NEEDS to be freed\&. 
.PP
\fBParameters\fP
.RS 4
\fIsource\fP string to copy 
.br
\fIlen\fP size of the new string 
.RE
.PP
\fBReturns\fP
.RS 4
char* pointer to the new string 
.RE
.PP

.PP
Definition at line \fB53\fP of file \fBft_strdup\&.c\fP\&.
.SS "char * ft_strnstr (const char * big, const char * little, size_t len)"

.PP
Search a substring in a bigger string, up to len position in string\&. 
.PP
\fBParameters\fP
.RS 4
\fIbig\fP string to search in 
.br
\fIlittle\fP string to search 
.br
\fIlen\fP max size of big 
.RE
.PP
\fBReturns\fP
.RS 4
char* pointer to the first occurence of little in big 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBft_strnstr\&.c\fP\&.
.SS "char * ft_strrchr (const char * string, int searched_char)"

.PP
Find last occurrence of searched_char\&. 
.PP
\fBParameters\fP
.RS 4
\fIstring\fP string to search in 
.br
\fIsearched_char\fP character to search 
.RE
.PP
\fBReturns\fP
.RS 4
char* pointer to the last occurrence of searched_char 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBft_strrchr\&.c\fP\&.
.SS "char * ft_strtrim (char const * s, char const * set)"

.PP
Deletes all characters that exist in s and set, if they are at the beginning of the string or at the end\&. 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to trim 
.br
\fIset\fP string of characters to trim 
.RE
.PP
\fBReturns\fP
.RS 4
char* new string 
.RE
.PP

.PP
Definition at line \fB26\fP of file \fBft_strtrim\&.c\fP\&.
.SS "char * ft_substr (char const * src, unsigned int start, size_t len)"

.PP
Create a copy of source into a new pointer, at start, of size len NEEDS to be freed\&. 
.PP
\fBParameters\fP
.RS 4
\fIsrc\fP string to copy 
.br
\fIstart\fP start of the copy 
.br
\fIlen\fP size of the copy 
.RE
.PP
\fBReturns\fP
.RS 4
char* new string 
.RE
.PP

.PP
Definition at line \fB26\fP of file \fBft_substr\&.c\fP\&.
.SS "void ft_swap_char (char * a, char * b)"

.PP
Swap 2 char values\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP

.PP
Definition at line \fB34\fP of file \fBft_swap\&.c\fP\&.
.SS "void ft_swap_char_no_temp (char * a, char * b)"

.PP
Works similarly as ft_swap_char but doens't use temporary variable SHOULD NOT BE USED IF a and b points at the same adress\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP

.PP
Definition at line \fB34\fP of file \fBft_swap_no_temp\&.c\fP\&.
.SS "void ft_swap_int (int * a, int * b)"

.PP
Swap 2 int values\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP

.PP
Definition at line \fB19\fP of file \fBft_swap\&.c\fP\&.
.SS "void ft_swap_int_no_temp (int * a, int * b)"

.PP
Works similarly as ft_swap_int but doens't use temporary variable SHOULD NOT BE USED IF a and b points at the same adress\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_swap_no_temp\&.c\fP\&.
.SS "void ft_swap_mem (void ** a, void ** b)"

.PP
Swap 2 memory adresses\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP

.PP
Definition at line \fB64\fP of file \fBft_swap\&.c\fP\&.
.SS "void ft_swap_mem_no_temp (void ** a, void ** b)"

.SS "void ft_swap_nodes (\fBt_list\fP ** start, \fBt_list\fP * lst1, \fBt_list\fP * lst2)"

.PP
Swap two nodes in a linked list (swap nodes, not content) 
.PP
\fBParameters\fP
.RS 4
\fIstart\fP head of the linked list 
.br
\fIlst1\fP First node to swap 
.br
\fIlst2\fP Second node to swap 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBft_swap_nodes\&.c\fP\&.
.SS "void ft_swap_str (char ** a, char ** b)"

.PP
Swap 2 string addresses\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP

.PP
Definition at line \fB49\fP of file \fBft_swap\&.c\fP\&.
.SS "void ft_swap_str_no_temp (char ** a, char ** b)"

.SS "int ft_tolower (int character)"

.PP
Transform majuscules into minuscules\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
character in minuscules if was in majuscules OR character isn´t majuscules 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_tolower\&.c\fP\&.
.SS "int ft_toupper (int character)"

.PP
Transform minuscules into majuscules\&. 
.PP
\fBParameters\fP
.RS 4
\fIcharacter\fP character to check 
.RE
.PP
\fBReturns\fP
.RS 4
character in majuscule if was in minuscule OR character isn´t minuscule 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBft_toupper\&.c\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Libft from the source code\&.
